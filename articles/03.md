# The Elegant Hack That Prevents Both Deadlock AND Livelock in PostgreSQL

> I was digging through PostgreSQL's INSERT ... ON CONFLICT code when I found this gem: a one-line rule that prevents two of the nastiest concurrency bugs at once. The fix? "The transaction with the higher XID backs out." That's it. Let me show you why it's brilliant.

---

## Every UPSERT Is a Dance

You've probably written this SQL a hundred times:

<!-- ğŸ–¼ï¸ INSERT IMAGE: code-upsert.png (or use code block below) -->

```sql
INSERT INTO users (email, name)
VALUES ('alice@example.com', 'Alice')
ON CONFLICT (email) DO UPDATE SET name = EXCLUDED.name;
```

Looks innocent, right? Insert if the row doesn't exist, update if it does. Under the hood though, this is surprisingly tricky.

Here's the thing â€” PostgreSQL can't just check-then-insert. Between your check and your insert, another transaction might slip in. Classic race condition. So PostgreSQL does something clever: it inserts first, _then_ checks for conflicts.

This is called **speculative insertion**. And it creates a fun coordination problem.

---

## The Problem: Two Transactions, Same Key, Same Moment

Picture this: two transactions trying to insert the same email at the exact same time.

<!-- ğŸ–¼ï¸ INSERT IMAGE: visual-race.png -->

```
Transaction A (XID 100):  INSERT INTO users VALUES ('alice@...')
Transaction B (XID 101):  INSERT INTO users VALUES ('alice@...')
```

Both transactions speculatively insert their row. Both rows exist (temporarily) in the table. Now both transactions scan for conflicts and â€” surprise â€” they find each other.

What now?

---

## Option 1: Both Wait â†’ DEADLOCK ğŸ’€

The obvious thing: each transaction waits for the other to finish.

<!-- ğŸ–¼ï¸ INSERT IMAGE: visual-deadlock.png -->

```
A: "I see B's row. I'll wait for B to finish..."
B: "I see A's row. I'll wait for A to finish..."

   â†“

Both: ğŸ’€ DEADLOCK
```

Neither can proceed. PostgreSQL would have to kill one of them. The deadlock detector will catch this eventually, but it's not great â€” detection takes time, and killing transactions is expensive.

---

## Option 2: Both Back Out â†’ LIVELOCK ğŸ”„

Okay, new plan: when you detect a conflict, back out your speculative insert, wait for the other transaction to finish, then retry.

Sounds reasonable. Let's see what happens:

<!-- ğŸ–¼ï¸ INSERT IMAGE: visual-livelock.png -->

```
A: "Conflict! I'll back out, wait for B, then retry."
B: "Conflict! I'll back out, wait for A, then retry."

   â†“

A: backs out
B: backs out

   â†“

A: "B is done! Let me retry..."
B: "A is done! Let me retry..."

   â†“

Both insert again. Both find each other. Again.

   â†“

ğŸ”„ Forever...
```

This is **livelock**. Both transactions are technically "making progress" â€” backing out, waiting, retrying â€” but neither ever completes. It's like two people in a hallway, both stepping aside to let the other pass, both stepping forward again, forever doing this awkward dance.

Here's the nasty part: livelocks don't trigger the deadlock detector. The system just spins, burning CPU, going nowhere.

---

## The Solution: One Simple Rule

Here's the fix I found in PostgreSQL's source:

<!-- ğŸ–¼ï¸ INSERT IMAGE: code-rule.png (or use code block below) -->

```c
/*
 * To avoid the livelock, one of the backends must back out first,
 * and then wait, while the other one waits without backing out.
 * It doesn't matter which one backs out, so we employ an arbitrary
 * rule that the transaction with the higher XID backs out.
 */
```

That's it. That's the whole idea.

Both transactions are doing the same thing. They're symmetric. But they're not _identical_ â€” each has a unique Transaction ID (XID). PostgreSQL exploits this asymmetry:

- **Higher XID** (the "younger" transaction): Back out, wait, then retry
- **Lower XID** (the "older" transaction): Just wait, keep your tuple in place

<!-- ğŸ–¼ï¸ INSERT IMAGE: visual-solution.png -->

No deadlock â€” only B backs out, so A isn't waiting for someone who's waiting for A.

No livelock â€” only one transaction backs out at a time.

---

## The Actual Implementation

Let's look at the real code. First, there's an enum that defines the different wait modes:

<!-- ğŸ–¼ï¸ INSERT IMAGE: code-wait-mode.png (or use code block below) -->

```c
/* src/backend/executor/execIndexing.c:122-128 */

typedef enum
{
    CEOUC_WAIT,                     /* Normal: wait for conflict to resolve */
    CEOUC_NOWAIT,                   /* Deferred: don't wait */
    CEOUC_LIVELOCK_PREVENTING_WAIT, /* Speculative: smart waiting */
} CEOUC_WAIT_MODE;
```

That `CEOUC_LIVELOCK_PREVENTING_WAIT` mode is where the magic happens. Here's the actual check:

<!-- ğŸ–¼ï¸ INSERT IMAGE: code-xid-check.png (or use code block below) -->

```c
/* src/backend/executor/execIndexing.c:876-880 */

if (TransactionIdIsValid(xwait) &&
    (waitMode == CEOUC_WAIT ||
     (waitMode == CEOUC_LIVELOCK_PREVENTING_WAIT &&
      DirtySnapshot.speculativeToken &&
      TransactionIdPrecedes(GetCurrentTransactionId(), xwait))))
{
    /* Wait for the other transaction */
```

Let me unpack this:

- `GetCurrentTransactionId()` â€” that's my XID
- `xwait` â€” the conflicting transaction's XID
- `TransactionIdPrecedes(mine, theirs)` â€” returns true if my XID is lower (I started earlier)

So: if my XID is lower (I'm the older transaction), I wait. If my XID is higher (I'm younger), I skip this block â€” which means I back out and retry instead.

---

## Why XID? Why Not Something Else?

You might wonder: why use Transaction IDs? Why not process IDs, timestamps, or a random coin flip?

Turns out XIDs are kind of perfect for this:

They're **unique** â€” every transaction gets exactly one. They're **comparable** â€” there's a clear ordering (with wraparound handling for the 32-bit counter). They're **free** â€” already available, no extra syscalls needed. And crucially, they're **consistent** â€” both transactions can independently look at each other's XID and reach the same conclusion about who should back off.

That last point is key. You need both sides to independently agree on who yields. XIDs make this trivial.

<!-- ğŸ–¼ï¸ INSERT IMAGE: visual-tiebreaker.png -->

---

## The Full Speculative Insertion Flow

Here's the complete picture of what happens during an INSERT ... ON CONFLICT:

<!-- ğŸ–¼ï¸ INSERT IMAGE: visual-flow.png -->

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ 1. Pre-check: Is there already a conflicting row?   â”‚
â”‚    â†’ If yes and committed: Do ON CONFLICT action    â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                        â”‚ no committed conflict
                        â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ 2. Acquire "speculative insertion lock"             â”‚
â”‚    (So others know we're in the middle of this)     â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                        â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ 3. Insert tuple speculatively                       â”‚
â”‚    (Tuple exists but is marked "speculative")       â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                        â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ 4. Insert index entries, check for conflicts        â”‚
â”‚    â†’ If conflict with committed row: abort, retry   â”‚
â”‚    â†’ If conflict with speculative row: XID check!   â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                        â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ 5. Mark tuple as "really inserted" or "killed"      â”‚
â”‚    Release speculative lock, wake up waiters        â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

The XID check happens at step 4. When two speculative insertions collide:

- The **younger** transaction (higher XID) goes back to step 1
- The **older** transaction (lower XID) waits at step 4

---

## This Pattern Is Everywhere

Once you see it, you notice this "deterministic tiebreaker" pattern all over distributed systems:

<!-- ğŸ–¼ï¸ INSERT IMAGE: visual-pattern.png -->

| System         | Tiebreaker           | Used For             |
| -------------- | -------------------- | -------------------- |
| PostgreSQL     | Transaction ID       | Livelock prevention  |
| Lamport Clocks | (timestamp, node_id) | Total ordering       |
| Raft           | (term, log_index)    | Leader election      |
| Bitcoin        | Block hash           | Chain selection      |
| Ethernet       | MAC address          | Collision resolution |

The common thread: when symmetric actors need asymmetric behavior, pick a deterministic property both can observe independently.

---

## The Commit That Added This

This feature landed on May 8, 2015:

<!-- ğŸ–¼ï¸ INSERT IMAGE: visual-commit.png -->

```
commit 168d5805e4c08bed7b95d351bf097cff7c07dd65
Author: Andres Freund
Date:   Fri May 8 05:31:36 2015 +0200

    Add support for INSERT ... ON CONFLICT DO NOTHING/UPDATE.

    This is implemented using a new infrastructure called "speculative
    insertion". It is an optimistic variant of regular insertion that
    first does a pre-check for existing tuples and then attempts an
    insert. If a violating tuple was inserted concurrently, the
    speculatively inserted tuple is deleted and a new attempt is made.

    Author: Peter Geoghegan, with significant contributions from
            Heikki Linnakangas and Andres Freund.
```

The speculative insertion approach was chosen specifically because it lets ON CONFLICT work without holding locks during the check phase â€” critical for high-concurrency workloads.

---

## What I Learned

**Livelocks are sneakier than deadlocks.** Deadlocks are dramatic â€” everything stops, the detector fires, someone gets killed. Livelocks are insidious. The system looks busy, progress seems to be happening, but nothing actually completes. When you're designing retry logic, always ask: "What happens if everyone retries at once?"

**Symmetry breaking is powerful.** When identical actors need different behavior, find a property they can all independently observe. It doesn't have to be meaningful â€” just unique and comparable. XIDs, process IDs, MAC addresses, timestamps... keep identifiers around. You never know when you'll need a tiebreaker.

**The comments tell the real story.** That 7-line comment in PostgreSQL doesn't just say what the code does. It explains the problem (two bad options), why they fail (deadlock, livelock), and why the solution works (asymmetric behavior). The comment is worth more than the code it describes.

<!-- ğŸ–¼ï¸ INSERT IMAGE: visual-lessons.png -->

---

## One More Thing

The PostgreSQL team could have just let the deadlock detector handle this. After all, deadlocks are detected and one transaction gets killed automatically. Why add extra complexity?

Because deadlock detection has a cost. It runs periodically, holds locks while scanning, and killing transactions is expensive (rollback, cleanup, client retry). The XID comparison? It's essentially free â€” just comparing two integers that you already have.

This is the difference between "it works" and "it works well at scale."

---

_What's the cleverest tiebreaking rule you've seen in code? I'd love to hear about it â€” find me on Twitter/X._

---

## Metadata

**Hashtags:** #postgresql #database #concurrency #deadlock #livelock #programming

**Reading time:** ~8 minutes

**Sources:**

- [PostgreSQL source code - src/backend/executor/execIndexing.c](https://github.com/postgres/postgres/blob/master/src/backend/executor/execIndexing.c)
- [PostgreSQL commit 168d5805](https://github.com/postgres/postgres/commit/168d5805e4c08bed7b95d351bf097cff7c07dd65)

---

## ğŸ–¼ï¸ Available Visuals (export from 03.html)

| Visual ID           | Description                                | Use After                                 |
| ------------------- | ------------------------------------------ | ----------------------------------------- |
| `visual-race`       | Two transactions racing to insert same key | "Two Transactions" section                |
| `visual-deadlock`   | Both wait â†’ deadlock diagram               | "Option 1: Both Wait" section             |
| `visual-livelock`   | Both back out â†’ livelock diagram           | "Option 2: Both Back Out" section         |
| `visual-solution`   | XID-based solution flow                    | "The Solution" section                    |
| `visual-tiebreaker` | Why XIDs work as tiebreakers               | "Why XID?" section                        |
| `visual-flow`       | Full speculative insertion flowchart       | "Full Speculative Insertion Flow" section |
| `visual-pattern`    | Where this pattern appears                 | "This Pattern Is Everywhere" section      |
| `visual-commit`     | The original commit info                   | "The Commit That Added This" section      |
| `visual-lessons`    | Key takeaways                              | "What I Learned" section                  |

### Code Snippets (styled)

| Code ID          | Description                     | Replaces                                 |
| ---------------- | ------------------------------- | ---------------------------------------- |
| `code-upsert`    | INSERT ... ON CONFLICT example  | Opening SQL example                      |
| `code-rule`      | The comment explaining the rule | "The Solution" code block                |
| `code-wait-mode` | CEOUC_WAIT_MODE enum            | "The Actual Implementation" first block  |
| `code-xid-check` | TransactionIdPrecedes check     | "The Actual Implementation" second block |
